[["index.html", "oepsData Package Documentation Chapter 1 Introduction", " oepsData Package Documentation Chapter 1 Introduction The Opioid Environment Policy Scan (OEPS) is an open-source data warehouse created by the Healthy Regions &amp; Policies Lab to support researchers in studying and modeling the opioid risk environment. This website is intended as a starting place for researchers interested in using the OEPS data. On this site, we have tutorials demonstrating two methods of accessing the Policy Scan’s data sets: first through an R package called oepsData, and secondly through bigrquery. We additionally provide a few example analyses using the data sets as a starting place for spatial research. To hear more on the project, check out the OEPS website. For more on the data itself, check out the in-depth data documentation or the online explorer "],["getting-started.html", "Chapter 2 Getting started", " Chapter 2 Getting started Installing oepsData is easy. Just run the following command to grab the newest release from GitHub. install.packages(&#39;devtools&#39;) ## Installing package into &#39;/Users/runner/work/_temp/Library&#39; ## (as &#39;lib&#39; is unspecified) ## also installing the dependencies &#39;credentials&#39;, &#39;zip&#39;, &#39;gitcreds&#39;, &#39;ini&#39;, &#39;httpuv&#39;, &#39;xtable&#39;, &#39;sourcetools&#39;, &#39;later&#39;, &#39;promises&#39;, &#39;systemfonts&#39;, &#39;textshaping&#39;, &#39;diffobj&#39;, &#39;rematch2&#39;, &#39;clipr&#39;, &#39;crayon&#39;, &#39;gert&#39;, &#39;gh&#39;, &#39;rprojroot&#39;, &#39;rstudioapi&#39;, &#39;whisker&#39;, &#39;shiny&#39;, &#39;callr&#39;, &#39;processx&#39;, &#39;downlit&#39;, &#39;httr2&#39;, &#39;ragg&#39;, &#39;xml2&#39;, &#39;stringr&#39;, &#39;xopen&#39;, &#39;brew&#39;, &#39;commonmark&#39;, &#39;stringi&#39;, &#39;praise&#39;, &#39;ps&#39;, &#39;waldo&#39;, &#39;usethis&#39;, &#39;desc&#39;, &#39;ellipsis&#39;, &#39;miniUI&#39;, &#39;pkgbuild&#39;, &#39;pkgdown&#39;, &#39;pkgload&#39;, &#39;profvis&#39;, &#39;rcmdcheck&#39;, &#39;remotes&#39;, &#39;roxygen2&#39;, &#39;rversions&#39;, &#39;sessioninfo&#39;, &#39;testthat&#39;, &#39;urlchecker&#39; ## ## The downloaded binary packages are in ## /var/folders/hw/1f0gcr8d6kn9ms0_wn0_57qc0000gn/T//RtmpZhu5m5/downloaded_packages devtools::install_github(&#39;https://github.com/healthyregions/oepsData&#39;) ## Using github PAT from envvar GITHUB_PAT. Use `gitcreds::gitcreds_set()` and unset GITHUB_PAT in .Renviron (or elsewhere) if you want to use the more secure git credential store instead. ## Downloading GitHub repo healthyregions/oepsData@HEAD ## R.methodsS3 (NA -&gt; 1.8.2 ) [CRAN] ## R.oo (NA -&gt; 1.26.0) [CRAN] ## R.utils (NA -&gt; 2.12.3) [CRAN] ## data.table (NA -&gt; 1.15.4) [CRAN] ## R.cache (NA -&gt; 0.16.0) [CRAN] ## Installing 5 packages: R.methodsS3, R.oo, R.utils, data.table, R.cache ## Installing packages into &#39;/Users/runner/work/_temp/Library&#39; ## (as &#39;lib&#39; is unspecified) ## ## The downloaded binary packages are in ## /var/folders/hw/1f0gcr8d6kn9ms0_wn0_57qc0000gn/T//RtmpZhu5m5/downloaded_packages ## ── R CMD build ───────────────────────────────────────────────────────────────── ## * checking for file ‘/private/var/folders/hw/1f0gcr8d6kn9ms0_wn0_57qc0000gn/T/RtmpZhu5m5/remotes11a14507ae66/healthyregions-oepsData-3e4ba05/DESCRIPTION’ ... OK ## * preparing ‘oepsData’: ## * checking DESCRIPTION meta-information ... OK ## * checking for LF line-endings in source and make files and shell scripts ## * checking for empty or unneeded directories ## Removed empty directory ‘oepsData/vignettes’ ## * building ‘oepsData_0.0.0.9000.tar.gz’ ## Installing package into &#39;/Users/runner/work/_temp/Library&#39; ## (as &#39;lib&#39; is unspecified) You can then load the package like any other R package: library(oepsData) Efforts are currently under way to list the package on CRAN. "],["basic-usage.html", "Chapter 3 Basic Usage 3.1 Cacheing", " Chapter 3 Basic Usage oepsData is centered around two functions: load_oeps_dictionary, which loads a basic data dictionary; and load_oeps, which directly loads OEPS data. We expect that most users will start by calling load_oeps_dictionary to look at what data is available at their desired analysis scale, followed by calling load_oeps to actually load the data. load_oeps_dictionary itself takes one argument – scale – that can be any of “tract”, “zcta”, “county”, or “state”. It returns the data dictionary (stored as a data.frame), so we recommend browsing it through the View command: # See what data is available at the state level data_dictionary &lt;- load_oeps_dictionary(scale=&quot;state&quot;) # if working in RStudio, we recommend: # View(data_dictionary) # as we&#39;re in a bookdown, we just preview it simply: data_dictionary We might find that we’re interested in the 1990 state data. We can load that data and its geometries using load_oeps. states_1990 &lt;- load_oeps(scale=&quot;state&quot;, year=1990, geometry=TRUE) head(data.frame(states_1990)) Which lets us operate on the data as we desire. For instance, we can make a simple map: library(tmap) #&gt; Breaking News: tmap 3.x is retiring. Please test v4, e.g. with #&gt; remotes::install_github(&#39;r-tmap/tmap&#39;) library(sf) #&gt; Linking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE # reproject to a better display CRS states_1990 &lt;- st_transform(states_1990, &quot;ESRI:102004&quot;) tm_shape(states_1990) + tm_fill(&quot;NoHsP&quot;, style=&quot;jenks&quot;) + tm_borders(alpha=0.05) + tm_layout(main.title = &quot;Population over 25 without a high school degree&quot;) 3.1 Cacheing oepsData pulls its data from online repositories, primarily GitHub. This can lead to issues for users operating on slow internet, for whom load times can be long for larger datasets, or for users who anticipate needing the package when entirely offline. To help minimize these issues, oepsData caches, or saves a local copy of, data loaded by load_oeps on its first load. Additionally, oepsData offers a few commands can help maintain caches: * cache_geometries and cache_oeps_tables cache all tables and geometries, overwriting prior ones in the process. * clear_cache deletes all cached data. * cache_dir returns the directory of the oepsData cache. Users who want to avoid using cached data and instead download data fresh every time can set cache=FALSE when calling load_oeps. "],["example-uses.html", "Chapter 4 Example uses 4.1 Data subsetting 4.2 Longitudinal analysis", " Chapter 4 Example uses 4.1 Data subsetting load_data offers a few tools to help subset data on first load. To get a better sense of how these tools can be put towards practical use, let’s walk through a quick and dirty spatial investigation of poverty and working age population in Chicago. We start by loading the data dictionary to see what data is available and into what themes they are categorized. This lets us request a subset of the full data set, which minimizes the amount of data in our environment at a time. # See what data is available data_dictionary &lt;- load_oeps_dictionary(scale=&#39;tract&#39;) # if working in RStudio, we recommend: # View(data_dictionary) data_dictionary Based on the data dictionary, we can see that we have two variables of interest – Age18_64 and PovP. Both variables are available at multiple time periods, and they belong to different themes – social and economic, respectively. Let’s pull our data using load_oeps. Note how many parameters we provide information for. Geographically, we provide the FIPS code for our desired states (just Illinois) and counties (just Cook), which dramatically cuts down the number of entries retrieved. Additionally, we provide our variables of interests’ themes, lowering the number of rows retrieved. # Grab the data cook_county_2010 &lt;- load_oeps( scale=&#39;tract&#39;, year=&#39;2010&#39;, themes=c(&#39;social&#39;, &#39;economic&#39;), states=&#39;17&#39;, counties=&#39;031&#39;, geometry=T) # Preview what we got head(data.frame(cook_county_2010)) We can then immediately map our data. We opt to use tmap in this example, but ggplot2 also has mapping functionality for users more familiar with the library. library(tmap) tm_shape(cook_county_2010) + tm_fill(c(&#39;Age18_64&#39;, &#39;PovP&#39;), title = c(&#39;Working Age&#39;, &#39;Poverty\\nPercentage&#39;), style = c(&#39;sd&#39;, &#39;sd&#39;), palette = &#39;BrBG&#39;) + tm_layout(legend.position = c(&#39;left&#39;, &#39;bottom&#39;), frame=FALSE) Based on the above, we observe that fewer working age individuals correlates roughly with higher poverty rates within the southern and western sides of Chicago, with this trend breaking down in northern suburbs. Chicagoland continues a little bit into northeastern Indiana; maybe the rough correlation is present there as well? To check, we can pass a list of county GEOIDS to the counties parameter of load_oeps. Note that these GEOIDS must consist of the state FIPS and county FIPS, as they would otherwise fail to uniquely identify our two counties. # Grab the data chicago_metro_2010 &lt;- load_oeps( scale=&#39;tract&#39;, year=&#39;2010&#39;, theme=c(&#39;social&#39;, &#39;economic&#39;), counties=c(&#39;17031&#39;, &#39;18089&#39;), geometry=T) # Preview what we got head(data.frame(cook_county_2010)) We can once again map the resultant data, and find that the rough correlation between lower working age population totals and higher poverty in more densely populated, coastal areas seems to hold for the broader Chicagoland area. library(tmap) tm_shape(chicago_metro_2010) + tm_fill(c(&#39;Age18_64&#39;, &#39;PovP&#39;), title = c(&#39;Working Age&#39;, &#39;Poverty\\nPercentage&#39;), style = c(&#39;sd&#39;, &#39;sd&#39;), palette = &#39;BrBG&#39;) + tm_layout(legend.position = c(&#39;left&#39;, &#39;bottom&#39;), frame=FALSE) 4.2 Longitudinal analysis Although not directly supported in the package, oepsData also enables easier longitudinal analysis. Continuing our above example, we might be interested in the change in percent poverty over time throughout Chicagoland. To check, let’s compare 2000 data to 2010 data. We start by grabbing data from 2000: # get new data chicago_metro_2000 &lt;- load_oeps( scale=&#39;tract&#39;, year=&#39;2000&#39;, theme=c(&#39;social&#39;, &#39;economic&#39;), counties=c(&#39;17031&#39;, &#39;18089&#39;), geometry=F) Note that chicago_metro_2000 and chicago_metro_2010 share column names, so we need to do some data wrangling for the merge. A wide variety of approaches exist, but we opt to use dplyr to select and rename our columns of interest. # rename data columns chicago_metro_2000 &lt;- dplyr::select(chicago_metro_2000, &quot;HEROP_ID&quot;, &quot;PovP2000&quot;=&quot;PovP&quot;) chicago_metro_2010 &lt;- dplyr::select(chicago_metro_2010, &quot;HEROP_ID&quot;, &quot;PovP2010&quot;=&quot;PovP&quot;) We can then merge the dataframes. Provided with oepsData are a HEROP specific merge-key – HEROP_ID – and a more common GEOID. We recommend merging on HEROP_ID when merging HEROP data, and reserving GEOID for compatability with outside datasets. # we changed the name of our merge keys earlier # so we resolve that here. chicago_metro_longitudinal &lt;- merge(chicago_metro_2010, chicago_metro_2000, by.x=&#39;HEROP_ID&#39;, by.y=&#39;HEROP_ID&#39;) With longitudinal data in hand, we can then conduct basic analyses on our data. For instance, we can make side-by-side maps of poverty rates: tm_shape(chicago_metro_longitudinal) + tm_fill(c(&#39;PovP2000&#39;, &#39;PovP2010&#39;), title = c(&#39;2000 Poverty\\nPercentage&#39;, &#39;2010 Poverty\\nPercentage&#39;), style = c(&#39;sd&#39;, &#39;sd&#39;), palette = &#39;BrBG&#39;) + tm_layout(legend.position = c(&#39;left&#39;, &#39;bottom&#39;), frame=FALSE) Or calculate the change in poverty: # make a new variable chicago_metro_longitudinal &lt;- dplyr::mutate(chicago_metro_longitudinal, ChangePovP = PovP2010 - PovP2000) tm_shape(chicago_metro_longitudinal) + tm_fill(&#39;ChangePovP&#39;, title = &quot;Change in Percent\\n Poverty, 2000 to 2010&quot;, style = &#39;jenks&#39;, palette = &#39;BrBG&#39;) + tm_layout(legend.position = c(&#39;left&#39;, &#39;bottom&#39;), frame=FALSE) #&gt; Variable(s) &quot;ChangePovP&quot; contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette. "],["getting-oeps-data-from-bigquery.html", "Chapter 5 Getting OEPS Data from BigQuery 5.1 Setting up BigQuery 5.2 Making Queries", " Chapter 5 Getting OEPS Data from BigQuery Opioid Environment Policy Scan data is available on Google BigQuery. In this notebook, we’ll go over how to interact with the data using bigrquery. We go over two of the bigrquery APIs – one for readers familiar with SQL, and one for readers who want to avoid SQL. Lastly, readers who are already familiar with Google BigQuery will likely want to skip to Make a Query. 5.1 Setting up BigQuery When making queries against a BigQuery dataset, we do not directly query the dataset. Instead, we connect to a BigQuery profile and submit a job, which tells the profile to make the query in our stead and return the data. You can think of this like connecting to another computer to middleman the exchange. The setup allows users to work with multiple BigQuery datasets within a single profile, and also allows for billing to be separated so that data providers only pay to store the data instead of also paying for all usage of their data. To enable BigQuery, sign into a Google account on your browser of choice before navigating to this link, where you will be prompted to “Enable BigQuery.” Do so to enable your account to access BigQuery and data through BigQuery. Once BigQuery is enabled, you’ll be taken to the BigQuery studio page. This page is a hub for BigQuery interaction on the cloud, and technically also a place from which you can test out SQL queries and manage connections to external databases. In the BigQuery diagram, it’s the computer on the cloud that you submit jobs to. For our purposes, we’re interested in the resources under the explorer. By default, Google creates a default resource by mashing together random words and numbers. You can proceed using this resource, or create a new, more memorably named resource through the “+ ADD” button at the top of the Explorer pane. Whichever route you take, we need to store the name of your BigQuery project in a variable for use. As it’s the project that gets billed for the queries, it’s conventional to refer to this project as “billing.” billing &lt;- &quot;oeps-tutorial&quot; # replace this with your project name! Lastly, we need to establish that we actually have permission to create jobs on the account we created. To do that, we can use bigrquery::bq_auth(), and then grant the Tidyverse API a few permissions on our Google Account. Note that this command will prompt you to open a new window in your browser. # Opens your browser to authenticate your account bigrquery::bq_auth() 5.2 Making Queries Now that we’ve enabled BigQuery on our account, we can use it to query the OEPS data on BigQuery. First, lets back up and look at the OEPS project at a broader level. Currently, the OEPS data warehouse on BigQuery is named oeps-391119, and is divided into two datasets: tabular and spatial. The tabular dataset consists of 16 tables of attribute data at the state, county, tract, and ZCTA scales from 1980 to 2020. The spatial dataset contains the 2010 TIGER/Line geometries for each of these scales. The primary key for the datasets are HEROP_ID. A full dataset schema can be found on the OEPS BigQuery reference linked here. bigrquery offers three interfaces for interacting with BigQuery, but we introduce two here: the low-level API that uses SQL, and a higher level method using dplyr. 5.2.1 The low-level API The low-level API offers a series of methods that can be used to interact with BigQuery’s REST API. While bigrquery offers quite a few commands, it’s usually sufficient to use two: bq_project_query and bq_table_download. Using these commands, we can create and submit SQL queries to pull data tables from the OEPS data warehouse: library(bigrquery) # Our query sql &lt;- &#39;SELECT HEROP_ID, TotPop, PovP FROM oeps-391119.tabular.C_1990&#39; # Submit a job to grab the data tb &lt;- bq_project_query(billing, query=sql) # Download the results of that query to our system results &lt;- bq_table_download(tb) head(results) We can also use more complex queries: sql &lt;- &#39; SELECT C_1990.HEROP_ID, (C_2000.PovP - C_1990.PovP) AS ChangeInPovP, (C_2000.TotPop - C_1990.TotPop) AS ChangeInPop FROM oeps-391119.tabular.C_1990 INNER JOIN oeps-391119.tabular.C_2000 ON C_1990.HEROP_ID=C_2000.HEROP_ID &#39; tb &lt;- bq_project_query(billing, sql) results &lt;- bq_table_download(tb) head(results) If we want to plot this data, we need to query the spatial database. This is doable, but R interactive environments are not always a fan of the result, so we’re forced to turn results into an sf object before attempting to preview it. That is, for the following setup: library(sf) sql &lt;- &#39;SELECT HEROP_ID, geom FROM oeps-391119.spatial.counties2010&#39; tb &lt;- bq_project_query(billing, sql) this breaks: # bad results &lt;- bq_table_download(tb) head(results) And this works: # This works results &lt;- bq_table_download(tb) |&gt; st_as_sf(wkt=&#39;geom&#39;, crs=&#39;EPSG:4326&#39;) # convert geom to sf head(results) 5.2.1.1 A full low-level pipeline: Putting this all together, we can create a quick map of how county level poverty changed from 1990 to 2000: library(tmap) tmap_mode(&#39;view&#39;) sql &lt;- &#39; SELECT C_1990.HEROP_ID, (C_2000.PovP - C_1990.PovP) AS ChangeInPovP, counties2010.name, counties2010.geom FROM oeps-391119.tabular.C_1990 INNER JOIN oeps-391119.tabular.C_2000 ON C_1990.HEROP_ID=C_2000.HEROP_ID INNER JOIN oeps-391119.spatial.counties2010 ON C_1990.HEROP_ID=counties2010.HEROP_ID &#39; tb &lt;- bq_project_query(billing, sql) results &lt;- bq_table_download(tb) |&gt; st_as_sf(wkt=&#39;geom&#39;, crs=&#39;EPSG:4326&#39;) tm_shape(results) + tm_fill(&#39;ChangeInPovP&#39;, style=&#39;sd&#39;, midpoint=0, title=&#39;Change in Poverty\\n 1990 to 2000&#39;, palette=&#39;-RdYlBu&#39;) 5.2.2 The dplyr API For users with less SQL familiarity, it’s also possible to use dplyr to interact with BigQuery. We’ll need the help of DBI, a library for interacting with databases in R. library(dplyr) library(DBI) library(bigrquery) For this pipeline, we use DBI to connect to a given dataset (e.g. tabular), before picking a table within the dataset to interact with and then manipulate that table using dplyr. # Connect to the tabular dataset conn &lt;- dbConnect( bigquery(), project = &#39;oeps-391119&#39;, dataset = &#39;tabular&#39;, billing = billing ) # List off available tables dbListTables(conn) We can then pick a table from the above and interact with it using dplyr. C_1990 &lt;- tbl(conn, &#39;C_1990&#39;) C_1990 |&gt; select(HEROP_ID, TotPop, PovP) |&gt; collect() |&gt; head() As with the low-level API, we can also do more complex tasks, albeit with a few more lines of code: C_1990 &lt;- tbl(conn, &#39;C_1990&#39;) |&gt; select(HEROP_ID, PovP1990=PovP, TotPop1990=TotPop) |&gt; collect() C_2000 &lt;- tbl(conn, &#39;C_2000&#39;) |&gt; select(HEROP_ID, PovP2000=PovP, TotPop2000=TotPop) |&gt; collect() changes &lt;- merge(C_2000, C_1990, on=&#39;HEROP_ID&#39;) |&gt; mutate(ChangeInPovP = PovP2000-PovP1990, ChangeInTotPop = TotPop2000-TotPop1990) |&gt; select(HEROP_ID, ChangeInPovP, ChangeInTotPop) |&gt; collect() head(changes) We can also interact with spatial data. This also requires the same hack as above: we cannot preview our results until after converting them to an sf object, at least within interactive R environments. In other words, with this connection to the spatial dataset: # Connect to the spatial dataset spatial_conn &lt;- dbConnect( bigquery(), project = &#39;oeps-391119&#39;, dataset = &#39;spatial&#39;, billing = billing ) This breaks: # breaks counties2010 &lt;- tbl(spatial_conn, &#39;counties2010&#39;) |&gt; collect() head(counties2010) and this works: # works counties2010 &lt;- tbl(spatial_conn, &#39;counties2010&#39;) |&gt; collect() |&gt; st_as_sf(wkt=&#39;geom&#39;, crs=&#39;EPSG:4326&#39;) head(counties2010) 5.2.2.1 A full dplyr pipeline: Putting all the pieces together, we can make our poverty map with the following code: # Make database connections spat_conn &lt;- dbConnect( bigquery(), project = &#39;oeps-391119&#39;, dataset = &#39;spatial&#39;, billing = billing ) tab_conn &lt;- dbConnect( bigquery(), project = &#39;oeps-391119&#39;, dataset = &#39;tabular&#39;, billing = billing ) # Grab tables C_1990 &lt;- tbl(tab_conn, &quot;C_1990&quot;) C_2000 &lt;- tbl(tab_conn, &quot;C_2000&quot;) counties2010 &lt;- tbl(spat_conn, &quot;counties2010&quot;) # Data wrangling C_1990 &lt;- C_1990 |&gt; select(HEROP_ID, PovP1990=PovP) |&gt; collect() C_2000 &lt;- C_2000 |&gt; select(HEROP_ID, PovP2000=PovP) |&gt; collect() change_in_pov &lt;- merge(C_2000, C_1990, on=&#39;HEROP_ID&#39;) |&gt; mutate(ChangeInPovP=PovP2000-PovP1990) |&gt; select(HEROP_ID, ChangeInPovP) counties2010 &lt;- counties2010 |&gt; collect() |&gt; st_as_sf(wkt=&#39;geom&#39;, crs=&#39;EPSG:4326&#39;) change_in_pov &lt;- merge(counties2010, change_in_pov, on=&#39;HEROP_ID&#39;) tm_shape(results) + tm_fill(&#39;ChangeInPovP&#39;, style=&#39;sd&#39;, midpoint=0, title=&#39;Change in Poverty\\n1990 to 2000&#39;, palette=&#39;-RdYlBu&#39;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
